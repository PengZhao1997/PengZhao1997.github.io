<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>贪心算法-合并果子</title>
      <link href="/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90/"/>
      <url>/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Problem-B-合并果子"><a href="#Problem-B-合并果子" class="headerlink" title="Problem B. 合并果子"></a>Problem B. 合并果子</h2><p>时间限制 1000 ms<br>内存限制 128 MB</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。<br>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。<br>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。<br>例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。</p><h3 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h3><p>输入包括两行，第一行是一个整数n(1 &lt;＝ n &lt; 10^4)，表示果子的种类数。第二行包含 n 个整数，用空格分隔，第 i 个整数ai(1 &lt;＝ ai &lt; 2 * 10^4)是第 i 种果子的数目。</p><h3 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h3><p>输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 2^31 。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 9</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这道题类似于哈夫曼编码树。首先用一个优先队列存储每种果子的数目，定义比较函数为从大到小排序。然后从队列中取出数目最少的两种果子，合并到一起，并将合并后的结果重新放入优先队列中，同时体力耗费增加相应的值。依此类推，直到将所有种类的果子合并成一堆。这样所得到的体力耗费值是最小的。</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;queue&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long int n, a, temp, result;</span><br><span class="line">priority_queue&lt;long long int, vector&lt;long long int&gt;, greater&lt;long long int&gt;&gt; fruits;</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        fruits.push(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fruits.size() &gt; 1) &#123;</span><br><span class="line">        temp = 0;</span><br><span class="line">        <span class="keyword">for</span> (i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            temp += fruits.top();</span><br><span class="line">            fruits.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        fruits.push(temp);</span><br><span class="line">        result += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最大稳定极值区域MSER-Maximally Stable Extrernal Regions</title>
      <link href="/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D/%E6%9C%80%E5%A4%A7%E7%A8%B3%E5%AE%9A%E6%9E%81%E5%80%BC%E5%8C%BA%E5%9F%9FMSER-Maximally-Stable-Extrernal-Regions/"/>
      <url>/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D/%E6%9C%80%E5%A4%A7%E7%A8%B3%E5%AE%9A%E6%9E%81%E5%80%BC%E5%8C%BA%E5%9F%9FMSER-Maximally-Stable-Extrernal-Regions/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>MSER基于分水岭的概念：对图像进行二值化，二值化阈值取[0, 255]，这样二值化图像就经历一个从全黑到全白的过程（就像水位不断上升的俯瞰图）。在这个过程中，有些连通区域面积随阈值上升的变化很小，这种区域就叫MSER。<br><img src="/images/mser.png" alt=""><br>其中Qi表示第i个连通区域的面积，Δ表示微小的阈值变化（注水），当vi小于给定阈值时认为该区域为MSER。<br>显然，这样检测得到的MSER内部灰度值是小于边界的，想象一副黑色背景白色区域的图片，显然这个区域是检测不到的。因此对原图进行一次MSER检测后需要将其反转，再做一次MSER检测，两次操作又称MSER+和MSER-。</p><h2 id="Python源码实现"><a href="#Python源码实现" class="headerlink" title="Python源码实现"></a>Python源码实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">im = cv2.imread(<span class="string">'./source.jpg'</span>)</span><br><span class="line">gray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">mser = cv2.MSER_create(_min_area=300)</span><br><span class="line">regions, boxes = mser.detectRegions(gray)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> box <span class="keyword">in</span> boxes:</span><br><span class="line">    x, y, w, h = box</span><br><span class="line">    cv2.rectangle(im, (x, y),(x + w, y + h), (255, 0, 0), 2)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">"./mser.jpg"</span>, im)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 目标检测与定位 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MSER </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>贪心算法_最小差距</title>
      <link href="/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E5%B7%AE%E8%B7%9D/"/>
      <url>/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E5%B7%AE%E8%B7%9D/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Problem-A-最小差距"><a href="#Problem-A-最小差距" class="headerlink" title="Problem A. 最小差距"></a>Problem A. 最小差距</h2><p>时间限制 1000 ms<br>内存限制 128 MB</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一些不同的一位数字，你可以从这些数字中选择若干个，并将它们按一定顺序排列，组成一个整数，把剩下的数字按一定顺序排列，组成另一个整数。组成的整数不能以0开头（除非这个整数只有1位）。<br>例如，给定6个数字，0,1,2,4,6,7，你可以用它们组成一对数10和2467，当然，还可以组成其他的很多对数，比如210和764，204和176。这些对数中两个数差的绝对值最小的是204和176，为28。<br>给定N个不同的0-9之间的数字，请你求出用这些数字组成的每对数中，差的绝对值最小的一对（或多对）数的绝对值是多少？</p><h3 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h3><p>第一行包括一个数 T （T ≤ 1000），为测试数据的组数。<br>每组数据包括两行，第一行为一个数 N （2 ≤ N ≤ 10），表示数字的个数。下面一行为 N 个不同的一位数字。</p><h3 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h3><p>T 行，每行一个数，表示第 i 个数据的答案。即最小的差的绝对值。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">6</span><br><span class="line">0 1 2 4 6 7</span><br><span class="line">4</span><br><span class="line">1 6 3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">28</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先将所有数字从小到大排序，接着这道题可以分三种情况考虑：<br>（1）只有两个数的情况：直接两数相减取绝对值即可。<br>（2）奇数个数的情况：首先保证第一个数字非0，如果为0，就将第一个数与第二个数交换位置，然后从左往右连续取<code>n/2+1</code>个数组成第一个整数，最后从右往左连续取<code>n/2</code>个数，即剩下的所有数组成另一个整数。这样所求得的一对整数的差的绝对值最小。<br>（3）偶数个数的情况：从左往右依次枚举，首先保证第一个数非0，如果为0，就从下一个数开始枚举；取第<code>k</code>个数作为第一个整数的第一个数字，取第<code>k+1</code>个数作为第二个整数的第一个数字；然后，对于剩下的数字，从右往左连续取<code>n/2-1</code>个数加入第一个整数中，从左往右连续取<code>n/2-1</code>个数加入第二个整数中；最后，取差的绝对值最小的一对整数。</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int t, n, d[20], num1, num2;</span><br><span class="line">int i, j, k, l, r;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    scanf(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; t; i++) &#123;</span><br><span class="line">        scanf(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">            scanf(<span class="string">"%d"</span>, &amp;d[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(d + 1, d + n + 1);</span><br><span class="line">        <span class="keyword">if</span> (n == 2) &#123; // 两个数的情况</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, abs(d[2] - d[1]));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n % 2 == 1) &#123; // 奇数个数的情况</span><br><span class="line">            <span class="keyword">if</span> (d[1] == 0) &#123;</span><br><span class="line">                swap(d[1], d[2]);</span><br><span class="line">            &#125;</span><br><span class="line">            num1 = 0, num2 = 0;</span><br><span class="line">            // 前n/2+1个数从左往右组成第一个整数</span><br><span class="line">            <span class="keyword">for</span> (j = 1; j &lt;= n / 2 + 1; j++) &#123;</span><br><span class="line">                num1 = num1 * 10 + d[j];</span><br><span class="line">            &#125;</span><br><span class="line">            // 后n/2个数从右往左组成第二个整数</span><br><span class="line">            <span class="keyword">for</span> (j = n; j &gt;= n / 2 + 2; j--) &#123;</span><br><span class="line">                num2 = num2 * 10 + d[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, abs(num1 - num2));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; // 偶数个数的情况</span><br><span class="line">            int result = 0x7fffffff;</span><br><span class="line">            // 枚举，取第k个数加入第一个整数中，取第k+1个数加入第二个整数中</span><br><span class="line">            <span class="keyword">for</span> (j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[j] == 0) &#123;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num1 = d[j], num2 = d[j + 1];</span><br><span class="line">                // 从右往左遍历n/2-1个数加入第一个整数中</span><br><span class="line">                // 从左往右遍历n/2-1个数加入第二个整数中</span><br><span class="line">                l = 1, r = n;</span><br><span class="line">                <span class="keyword">for</span> (k = 0; k &lt; n / 2 - 1; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (l == j) l++;</span><br><span class="line">                    <span class="keyword">if</span> (l == j + 1) l++;</span><br><span class="line">                    <span class="keyword">if</span> (r == j + 1) r--;</span><br><span class="line">                    <span class="keyword">if</span> (r == j) r--;</span><br><span class="line">                    num1 = num1 * 10 + d[r];</span><br><span class="line">                    num2 = num2 * 10 + d[l];</span><br><span class="line">                    l++, r--;</span><br><span class="line">                &#125;</span><br><span class="line">                // 取差最小的值</span><br><span class="line">                result = min(result, abs(num1 - num2));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>贪心算法_旅行</title>
      <link href="/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%97%85%E8%A1%8C/"/>
      <url>/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%97%85%E8%A1%8C/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Problem-D-旅行"><a href="#Problem-D-旅行" class="headerlink" title="Problem D. 旅行"></a>Problem D. 旅行</h2><p>时间限制 1000 ms<br>内存限制 128 MB</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>某趟列车的最大载客容量为V人，沿途共有n个停靠站，其中始发站为第1站，终点站为第n站。<br>在第1站至第n-1站之间，共有m个团队申请购票搭乘，若规定：<br>（1）对于某个团队的购票申请，要么全部满足，要么全部拒绝，即不允许只满足部分。（2）每个乘客的搭乘费用为其所乘站数。<br>问：应如何选择这些购票申请，能使该趟列车获得最大的搭乘费用？<br>其中，每个团队的购票申请格式是以空格分隔的三个整数：a b t，即表示有t个人需要从第a站点乘至第b站点（注：每个团队的所有人员都必须同时在a站上车，且必须同时在后面的b站下车）。</p><h3 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h3><p>输入数据有若干行。<br>第 1 行只有三个整数 n，m，v，分别表示站点数、申请数、列车的最大载客容量。这三个整数之间都以一个空格分隔。<br>第 2 行至第 m+1 行，每行有三个整数，中间都以一个空格分隔。其中第 k+1 行的三个整数 a，b，t 表示第 k 个申请，含义为：有 t 个人需要从第 a 站乘至第 b 站。<br>其中：1 ≤ n ≤ 10；1 ≤ m ≤ 18</p><h3 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h3><p>输出数据只有一行，该行只有一个整数，为该列车能获得的最大搭乘费用。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3  3  5</span><br><span class="line">1  2  2</span><br><span class="line">2  3  5</span><br><span class="line">1  3  4</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这道题与0-1背包问题类似。直接枚举所有可能的方案数，对于每一个团队，只有两个选择，搭乘与不搭乘，可以采用二进制0与1枚举的方式。由于团队申请数目<code>m</code>最多只有<code>18</code>个，所以最多有<code>2^18</code>种方案。对于每一种方案，统计每一站车上的总人数，如果某一站车上总人数超过了列车的最大载客容量<code>v</code>，那么此方案不可行；否则，比较搭乘费用，取最大的搭乘费用即可。</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m, v, a[20], b[20], t[20], num[25];</span><br><span class="line">long long cost = 0, temp;</span><br><span class="line">bool flag;</span><br><span class="line">int i, j;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    // 枚举二进制方案数</span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; (1 &lt;&lt; m); i++) &#123;</span><br><span class="line">        // 变量的初始化</span><br><span class="line">        temp = 0;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        memset(num, 0, sizeof(num));</span><br><span class="line">        // 判断决定每一个团队是否可以搭乘</span><br><span class="line">        <span class="keyword">for</span> (j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; (1 &lt;&lt; j)) &#123;</span><br><span class="line">                num[a[j]] += t[j];</span><br><span class="line">                num[b[j]] -= t[j];</span><br><span class="line">                temp += (b[j] - a[j]) * t[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 统计每一站车上的总人数，如果大于容量，就不满足条件</span><br><span class="line">        <span class="keyword">for</span> (j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">            num[j] += num[j - 1];</span><br><span class="line">            <span class="keyword">if</span> (num[j] &gt; v) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 满足条件则取最大搭乘费用</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            cost = max(cost, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cost &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>非极大值抑制NMS(Non-Maximum Suppression)</title>
      <link href="/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D/%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6NMS-Non-Maximum-Suppression/"/>
      <url>/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D/%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6NMS-Non-Maximum-Suppression/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>NMS顾名思义就是抑制不是极大值的元素，可以理解为局部最大搜索。这个局部代表的是一个邻域，邻域有两个参数可变，一是邻域的维数，二是邻域的大小。在目标检测中NMS主要用于提取分数最高的候选框。例如在用训练好的模型进行测试时，网络会预测出一系列的候选框，这时候可以用NMS来移除一些多余的候选框，即移除一些IOU值大于某个阈值的框。再比如在行人检测中，滑动窗口经提取特征，经分类器分类识别后，每个窗口都会得到一个分数。但是滑动窗口会导致很多窗口与其他窗口存在包含或者大部分交叉的情况。这时就需要用NMS来选取那些邻域里分数最高（是行人的概率最大）的窗口，并且抑制那些分数低的窗口。<br>NMS在计算机视觉领域有着非常重要的应用，如视频目标跟踪、数据挖掘、3D重建、目标识别以及纹理分析等等。</p><h2 id="NMS在目标检测中的应用"><a href="#NMS在目标检测中的应用" class="headerlink" title="NMS在目标检测中的应用"></a>NMS在目标检测中的应用</h2><h4 id="去除重叠人脸检测框的例子"><a href="#去除重叠人脸检测框的例子" class="headerlink" title="去除重叠人脸检测框的例子"></a>去除重叠人脸检测框的例子</h4><p><img src="/images/NMS1.png" alt=""><br>如上图所示，目的就是要去除冗余的检测框，找到最佳的候选框。</p><h4 id="目标检测pipline中的例子"><a href="#目标检测pipline中的例子" class="headerlink" title="目标检测pipline中的例子"></a>目标检测pipline中的例子</h4><p><img src="/images/NMS2.png" alt=""><br>如上图所示，产生<strong>proposal</strong>后使用分类网络给出每个框的每类置信度，使用回归网络修正位置，最后使用NMS去除冗余的检测框。</p><h4 id="NMS算法原理"><a href="#NMS算法原理" class="headerlink" title="NMS算法原理"></a>NMS算法原理</h4><p>对于<strong>bounding boxes</strong>列表<strong>B</strong>及其相应的置信度<strong>S</strong>，使用下述计算方式：选择具有最大<strong>score</strong>的检测框<strong>M</strong>，将其从<strong>B</strong>集合中移除并加入到最后的检测结果<strong>R</strong>中。通常将<strong>B</strong>中剩余检测框与<strong>M</strong>的IOU大于阈值<strong>threshold</strong>的框从<strong>B</strong>中移除。重复这个过程，直到<strong>B</strong>为空。<br>其中用到的排序，可以按照检测框右下角的坐标或者面积排序，也可以通过SVM等分类器得到的得分或概率进行排序，R-CNN中就是按照得分进行的排序。<br><img src="/images/NMS3.png" alt=""><br>比如上图，定位一个车辆的位置，算法找出了许多检测框，这时需要判断哪些矩形框是没用的。<br>非极大值抑制的方法是：先假设有6个矩形框，按照候选框的类别分类概率排序，假设属于车辆的概率排序结果为<strong>A &lt; B &lt; C &lt; D &lt; E &lt; F</strong>。</p><ol><li>先从最大概率矩形框<strong>F</strong>开始，分别判断<strong>A</strong>~<strong>E</strong>与<strong>F</strong>的IOU值是否大于某个设定的阈值；</li><li>假设<strong>B</strong>、<strong>D</strong>与<strong>F</strong>的重叠度超过设定的阈值，那么就移除<strong>B</strong>和<strong>D</strong>；并标记第一个矩形框<strong>F</strong>，是保留下来的。</li><li>从剩下的矩形框<strong>A</strong>、<strong>C</strong>、<strong>E</strong>中，选择概率最大的<strong>E</strong>，然后判断<strong>E</strong>与<strong>A</strong>、<strong>C</strong>的重叠度，如果重叠度大于设定的阈值，那么就扔掉；并标记<strong>E</strong>是保留下来的第二个矩形框。</li></ol><p>就这样一直重复，直到找到所有被保留下来的矩形框。</p><h4 id="Python源码实现"><a href="#Python源码实现" class="headerlink" title="Python源码实现"></a>Python源码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">def py_cpu_nms(dets, thresh):</span><br><span class="line"><span class="string">""</span><span class="string">" Pure Python NMS baseline. "</span><span class="string">""</span></span><br><span class="line"><span class="comment"># x1、y1、x2、y2、以及score赋值</span></span><br><span class="line">x1 = dets[:, 0]</span><br><span class="line">y1 = dets[:, 1]</span><br><span class="line">x2 = dets[:, 2]</span><br><span class="line">y2 = dets[:, 3]</span><br><span class="line">scores = dets[:, 4]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一个候选框的面积</span></span><br><span class="line">areas = (x2 - x1 + 1) * (y2 - y1 + 1)</span><br><span class="line"><span class="comment"># 按照score置信度降序排序</span></span><br><span class="line">order = scores.argsort()[::-1]</span><br><span class="line"></span><br><span class="line">keep = [] <span class="comment"># 保留的结果框集合</span></span><br><span class="line"><span class="keyword">while</span> order.size &gt; 0:</span><br><span class="line">i = order[0]</span><br><span class="line">keep.append(i) <span class="comment"># 保留该类剩余box中得分最高的一个</span></span><br><span class="line"><span class="comment"># 计算当前概率最大矩形框与其他矩形框的相交框的坐标</span></span><br><span class="line">xx1 = np.maximum(x1[i], x1[order[1:]])</span><br><span class="line">yy1 = np.maximum(y1[i], y1[order[1:]])</span><br><span class="line">xx2 = np.minimum(x2[i], x2[order[1:]])</span><br><span class="line">yy2 = np.minimum(y2[i], y2[order[1:]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算相交的面积，不重叠时面积为0</span></span><br><span class="line">w = np.maximum(0.0, xx2 - xx1 + 1)</span><br><span class="line">h = np.maximum(0.0, yy2 - yy1 + 1)</span><br><span class="line">inter = w * h</span><br><span class="line"><span class="comment">#计算IoU：重叠面积 /（面积1+面积2-重叠面积）</span></span><br><span class="line">over = inter / (areas[i] + areas[order[1:]] - inter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留IoU小于阈值的矩形框索引</span></span><br><span class="line">inds = np.where(over &lt;= thresh)[0]</span><br><span class="line"><span class="comment"># 将order序列更新，由于前面得到的矩形框索引要比矩形框在原order序列中的索引小1，所以要把这个1加回来</span></span><br><span class="line">order = order[inds + 1]</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> keep <span class="comment"># 获取保留下来的索引</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 目标检测与定位 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NMS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>交并比IOU(Intersection over Union)</title>
      <link href="/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D/%E4%BA%A4%E5%B9%B6%E6%AF%94IOU-Intersection-over-Union/"/>
      <url>/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D/%E4%BA%A4%E5%B9%B6%E6%AF%94IOU-Intersection-over-Union/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>IOU是在目标检测中使用的一个概念，是产生的预测框(<strong>Predicted bounding box</strong>)与标注框(<strong>Ground-truth bounding box</strong>)的重叠率；简单来说，即两个矩形框面积的交集和并集的比值；它是一个在特定数据集中检测相应物体准确度的测量标准。通常会在<strong>HOG + Linear SVM object detectors</strong>和<strong>Convolutional Neural Network detectors (R-CNN, Faster R-CNN, YOLO 等)</strong>中使用该方法检测其性能。<br>IOU是一个简单的测量标准，在输出中得出一个预测范围(<strong>bounding box</strong>)的任务都可以用IOU来测量。其用于测量真实和预测之间的相关度，相关度越高，该值越高。<br><img src="/images/IOU1.jpg" alt=""><br>上图展示了<strong>ground-truth</strong>和<strong>predicted</strong>的结果，绿色标线是人为标记的正确结果，红色标线是算法预测出来的结果，IOU要做的就是在这两个结果中测量算法的准确度。<br><img src="/images/IOU2.png" alt=""><br><img src="/images/IOU3.png" alt=""><br>一般来说，这个比值 ＞ 0.5 就可以认为是一个不错的结果了。<br><img src="/images/IOU4.png" alt=""></p><h2 id="Python源码实现"><a href="#Python源码实现" class="headerlink" title="Python源码实现"></a>Python源码实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">def compute_iou(box1, box2, wh=False):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    compute the iou of two boxes.</span></span><br><span class="line"><span class="string">    args:</span></span><br><span class="line"><span class="string">        box1, box2: [xmin, ymin, xmax, ymax] (wh=False) or [xcenter, ycenter, w, h] (wh=True)</span></span><br><span class="line"><span class="string">        wh: the format of coordinate.</span></span><br><span class="line"><span class="string">    return:</span></span><br><span class="line"><span class="string">        iou: iou of box1 and box2.</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> wh == False:</span><br><span class="line">        xmin1, ymin1, xmax1, ymax1 = box1</span><br><span class="line">        xmin2, ymin2, xmax2, ymax2 = box2</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        xmin1, ymin1 = int(box1[0] - box1[2] / 2.0), int(box1[1] - box1[3] / 2.0)</span><br><span class="line">        xmax1, ymax1 = int(box1[0] + box1[2] / 2.0), int(box1[1] + box1[3] / 2.0)</span><br><span class="line">        xmin2, ymin2 = int(box2[0] - box2[2] / 2.0), int(box2[1] - box2[3] / 2.0)</span><br><span class="line">        xmax2, ymax2 = int(box2[0] + box2[2] / 2.0), int(box2[1] + box2[3] / 2.0)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 计算两个矩形框面积</span></span><br><span class="line">    area1 = (xmax1 - xmin1) * (ymax1 - ymin1)</span><br><span class="line">    area2 = (xmax2 - xmin2) * (ymax2 - ymin2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 获取矩形框交集对应的左上角和右下角的坐标（intersection）</span></span><br><span class="line">    inter_x1 = np.max([xmin1, xmin2])</span><br><span class="line">    inter_y1 = np.max([ymin1, ymin2])</span><br><span class="line">    inter_x2 = np.min([xmax1, xmax2])</span><br><span class="line">    inter_y2 = np.min([ymax1, ymax2])</span><br><span class="line"></span><br><span class="line">    inter_area = (np.max([0, inter_x2 - inter_x1])) * (np.max([0, inter_y2 - inter_y1]))　<span class="comment"># 计算交集面积</span></span><br><span class="line">    iou = inter_area / (area1 + area2 - inter_area + 1e-6)　＃ 计算交并比</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> iou</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 目标检测与定位 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOU </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git基本常用命令</title>
      <link href="/%E5%B7%A5%E5%85%B7/Git%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/%E5%B7%A5%E5%85%B7/Git%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><strong>git init</strong> 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。</li><li><strong>git add XX</strong> 把xx文件添加到暂存区去。</li><li><strong>git commit -m ‘XX’</strong> 提交文件， –m 后面的是注释。</li><li><strong>git status</strong> 查看本地仓库状态。</li><li><strong>git diff XX</strong> 查看XX文件修改了那些内容。</li><li><strong>git log</strong> 查看历史记录。</li><li><strong>git reset -hard HEAD^</strong> 或者 <strong>git reset –hard HEAD~</strong> 回退到上一个版本(如果想回退到100个版本，使用<strong>git reset –hard HEAD~100</strong> )。</li><li><strong>cat XX</strong> 查看XX文件内容。</li><li><strong>git reflog</strong> 查看历史记录的版本号id。</li><li><strong>git checkout – XX</strong> 把XX文件在工作区的修改全部撤销。</li><li><strong>git rm XX</strong> 删除XX文件。</li><li><strong>git remote add origin <a href="https://github.com/zhaopeng0103/test.git" target="_blank" rel="noopener">https://github.com/zhaopeng0103/test.git</a></strong> 关联一个远程库。</li><li><strong>git push –u(第一次要用-u 以后不需要) origin master</strong> 把当前master分支推送到远程库。</li><li><strong>git clone <a href="https://github.com/zhaopeng0103/test.git" target="_blank" rel="noopener">https://github.com/zhaopeng0103/test.git</a></strong> 从远程库中克隆。</li><li><strong>git checkout –b dev</strong> 创建dev分支，并切换到dev分支上。</li><li><strong>git branch</strong> 查看当前所有的分支。</li><li><strong>git checkout master</strong> 切换回master分支。</li><li><strong>git merge dev</strong> 在当前的分支上合并dev分支。</li><li><strong>git branch –d dev</strong> 删除dev分支。</li><li><strong>git branch name</strong> 创建分支。</li><li><strong>git stash</strong> 把当前的工作隐藏起来 等以后恢复现场后继续工作。</li><li><strong>git stash list</strong> 查看所有被隐藏的文件列表。</li><li><strong>git stash apply</strong> 恢复被隐藏的文件，但是内容不删除。</li><li><strong>git stash drop</strong> 删除文件。</li><li><strong>git stash pop</strong> 恢复文件的同时 也删除文件。</li><li><strong>git remote</strong> 查看远程库的信息。</li><li><strong>git remote –v</strong> 查看远程库的详细信息。</li><li><strong>git push origin master</strong> Git会把master分支推送到远程库对应的远程分支上。</li></ul>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git使用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>好听的歌曲</title>
      <link href="/music/%E5%A5%BD%E5%90%AC%E7%9A%84%E6%AD%8C%E6%9B%B2/"/>
      <url>/music/%E5%A5%BD%E5%90%AC%E7%9A%84%E6%AD%8C%E6%9B%B2/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <div id="aplayer-QrlMGTmu" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","music":[{"title":"小白兔遇上卡布奇诺","author":"兔子牙","url":"/music/小白兔遇上卡布奇诺.mp3","pic":"/images/小白兔1.jpg","lrc":"/documents/小白兔.txt"}]};  options.element = document.getElementById("aplayer-QrlMGTmu");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","video":{"url":"/videos/小白兔.mp4","pic":"/images/小白兔.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      <categories>
          
          <category> music </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序设计竞赛:五子棋</title>
      <link href="/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E4%BA%94%E5%AD%90%E6%A3%8B/"/>
      <url>/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E4%BA%94%E5%AD%90%E6%A3%8B/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Problem-E-五子棋"><a href="#Problem-E-五子棋" class="headerlink" title="Problem E. 五子棋"></a>Problem E. 五子棋</h2><p>时间限制 1000 ms<br>内存限制 64 MB</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个nxn的棋盘上，有一些黑色的棋子和白色的棋子，如果能找出任意五个同色的棋子连成直线（横着、竖着、斜着都可以），那么该颜色方加1分。求黑色方得分和白色方得分。</p><h3 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h3><p>第一行为一个正整数n，代表棋盘的大小。 接下来为一个nxn的矩阵，’#’代表没有棋子，’B’代表黑色棋子，’W’代表白色棋子 n&lt;=20</p><h3 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h3><p>两个正整数，分别代表黑色方得分和白色方得分</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">WBBBBB</span><br><span class="line">WBB<span class="comment">###</span></span><br><span class="line">W<span class="comment">###B#</span></span><br><span class="line">W<span class="comment">###B#</span></span><br><span class="line">W<span class="comment">###B#</span></span><br><span class="line">W<span class="comment">###B#</span></span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>直接遍历每一个棋子，如果在下图中的任一个方向连成5个，则对应方加1分。<br><img src="/images/wuziqi.png" alt=""></p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxN = 40;</span><br><span class="line">int n;</span><br><span class="line">int a[maxN][maxN], b_score, w_score;</span><br><span class="line">string s;</span><br><span class="line">int i, j;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    memset(a, 0, sizeof(a));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (i = 3; i &lt; n + 3; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (j = 0; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="string">'B'</span>) &#123;</span><br><span class="line">                a[i][j + 3] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="string">'W'</span>) &#123;</span><br><span class="line">                a[i][j + 3] = 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = 3; i &lt; n + 3; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = 3; j &lt; n + 3; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == 1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j - 1] == a[i][j] &amp;&amp; a[i][j - 2] == a[i][j] &amp;&amp; a[i][j + 1] == a[i][j] &amp;&amp; a[i][j + 2] == a[i][j]) &#123;</span><br><span class="line">                    b_score++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[i - 1][j] == a[i][j] &amp;&amp; a[i - 2][j] == a[i][j] &amp;&amp; a[i + 1][j] == a[i][j] &amp;&amp; a[i + 2][j] == a[i][j]) &#123;</span><br><span class="line">                    b_score++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[i + 1][j + 1] == a[i][j] &amp;&amp; a[i + 2][j + 2] == a[i][j] &amp;&amp; a[i - 1][j - 1] == a[i][j] &amp;&amp; a[i - 2][j - 2] == a[i][j]) &#123;</span><br><span class="line">                    b_score++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[i + 1][j - 1] == a[i][j] &amp;&amp; a[i + 2][j - 2] == a[i][j] &amp;&amp; a[i - 1][j + 1] == a[i][j] &amp;&amp; a[i - 2][j + 2] == a[i][j]) &#123;</span><br><span class="line">                    b_score++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == 2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j - 1] == a[i][j] &amp;&amp; a[i][j - 2] == a[i][j] &amp;&amp; a[i][j + 1] == a[i][j] &amp;&amp; a[i][j + 2] == a[i][j]) &#123;</span><br><span class="line">                    w_score++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[i - 1][j] == a[i][j] &amp;&amp; a[i - 2][j] == a[i][j] &amp;&amp; a[i + 1][j] == a[i][j] &amp;&amp; a[i + 2][j] == a[i][j]) &#123;</span><br><span class="line">                    w_score++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[i + 1][j + 1] == a[i][j] &amp;&amp; a[i + 2][j + 2] == a[i][j] &amp;&amp; a[i - 1][j - 1] == a[i][j] &amp;&amp; a[i - 2][j - 2] == a[i][j]) &#123;</span><br><span class="line">                    w_score++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[i + 1][j - 1] == a[i][j] &amp;&amp; a[i + 2][j - 2] == a[i][j] &amp;&amp; a[i - 1][j + 1] == a[i][j] &amp;&amp; a[i - 2][j + 2] == a[i][j]) &#123;</span><br><span class="line">                    w_score++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; b_score &lt;&lt; <span class="string">" "</span> &lt;&lt; w_score &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 程序设计竞赛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序设计竞赛:讨厌的数字</title>
      <link href="/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E8%AE%A8%E5%8E%8C%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E8%AE%A8%E5%8E%8C%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Problem-D-讨厌的数字"><a href="#Problem-D-讨厌的数字" class="headerlink" title="Problem D. 讨厌的数字"></a>Problem D. 讨厌的数字</h2><p>时间限制 1000 ms<br>内存限制 64 MB</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>奶牛的生日快到了，你准备送给他一个数x作为生日礼物，x是十进制下的一个n位数，但是奶牛向你提出了一些要求。 1 奶牛准备了一个数字d，他希望x是d的倍数 2 奶牛不喜欢0和3，他不希望x中有0或3 请问有多少个不同的n位数可以作为奶牛的生日礼物呢？ 答案mod1000000007输出。</p><h3 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h3><p>两个数字n和d，代表数字位数和奶牛给出的数字d<br>0 &lt;= n &lt;= 1000<br>0 &lt;= d &lt;= 1000</p><h3 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h3><p>一个1000000007之内的整数代表答案</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><code>dp[i][j]</code>表示<code>i</code>位数中模<code>d</code>等于<code>j</code>的方案数。首先计算只有一位数时，满足条件的方案数作为初始值。然后依次遍历<code>i</code>位数下对<code>d</code>求余为<code>j</code>的方案个数；每增加一位数，就在其最后加<code>k</code>，因为要求数字中不能出现<code>0</code>和<code>3</code>，那么遍历时直接去除这两个数字就可以了。最后<code>n</code>位数下是<code>d</code>的倍数的方案个数就是<code>dp[n][0]</code>。</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxN = 1010;</span><br><span class="line">int n, d, dp[maxN][maxN];</span><br><span class="line">int i, j, k;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    // 计算一位数的方案数</span><br><span class="line">    <span class="keyword">for</span> (k = 1; k &lt;= 9; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == 3) &#123;</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[1][k % d]++;</span><br><span class="line">    &#125;</span><br><span class="line">    // dp[i][j]表示i位数中模d等于j的方案数</span><br><span class="line">    <span class="keyword">for</span> (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = 0; j &lt; d; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = 1; k &lt;= 9; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k == 3) &#123;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][(j * 10 + k) % d] += dp[i - 1][j];</span><br><span class="line">                dp[i][(j * 10 + k) % d] %= 1000000007;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][0] &lt;&lt; endl;// 输出n位数中能被d整除的满足条件的方案数</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计竞赛 </tag>
            
            <tag> 动态规划dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序设计竞赛:约瑟夫环plus</title>
      <link href="/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AFplus/"/>
      <url>/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AFplus/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Problem-C-约瑟夫环plus"><a href="#Problem-C-约瑟夫环plus" class="headerlink" title="Problem C. 约瑟夫环plus"></a>Problem C. 约瑟夫环plus</h2><p>时间限制 2000 ms<br>内存限制 64 MB</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>考虑经典的约瑟夫环模型：n个人按顺序围成一圈，从第一个人开始报数，从1开始报，报到k这个数的人会被移出去，然后下一个人从1开始重新报数，第n个人报完数之后第1个人接着报数，问整个过程中第1个人报了几次数。</p><h3 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h3><p>两个正整数n，k<br>1 &lt;= n &lt;= 1000000000000000000<br>1 &lt;= k &lt;= 200</p><h3 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h3><p>第1个人被移除之前一共报了几次数</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>注意n需要用long long存</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><code>cur_number</code>存储第一个人每次轮到他时所报的号，最开始时，第一个人报号的次数<code>res</code>为<code>1</code>，<code>cur_number</code>也为<code>1</code>；从上一次这个人报号到下一次轮到他报号为止为一个周期，在这个周期内有<code>(n + cur_number) / k</code>个人被移出去，这个人报的号更新为<code>(n + cur_number) % k</code>；所以当<code>(n + cur_number) % k = 0</code>时，第一个人会被移出去，也就是下一次轮到他时<code>cur_number = 0</code>。</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long n, k, cur_number, res, temp;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    res = 1;</span><br><span class="line">    cur_number = 1;</span><br><span class="line">    <span class="keyword">while</span> (cur_number != 0) &#123;</span><br><span class="line">        temp = n + cur_number;</span><br><span class="line">        n -= temp / k;</span><br><span class="line">        cur_number = temp % k;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 程序设计竞赛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序设计竞赛:魔法师排队</title>
      <link href="/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E9%AD%94%E6%B3%95%E5%B8%88%E6%8E%92%E9%98%9F/"/>
      <url>/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E9%AD%94%E6%B3%95%E5%B8%88%E6%8E%92%E9%98%9F/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Problem-B-魔法师排队"><a href="#Problem-B-魔法师排队" class="headerlink" title="Problem B. 魔法师排队"></a>Problem B. 魔法师排队</h2><p>时间限制 2000 ms<br>内存限制 64 MB</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有n个魔法师在排队买魔法面包，每个魔法师都有自己的魔力值，用一个正整数表示。 魔法师都不喜欢排队，如果任意时刻某个魔法师发现前面的魔法师的魔力值比自己小，那么这个魔法师就会用法术把前面的人传送到异空间。 请输出有多少个魔法师会被传送到异空间。</p><h3 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h3><p>第一行为一个正整数n，代表魔法师的人数。 接下来一行位n个正整数，第i个正整数ai代表队伍中第i个魔法师的魔力值。（第1个魔法师在队头，第n个魔法师在队尾）<br>1 &lt;= n &lt;= 1000000<br>1 &lt;= ai &lt;= 100000000</p><h3 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h3><p>被传送到异空间的魔法师个数</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">4 5 1 3 2</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一开始的想法是：找从第一个魔法师到最后一个魔法师中的拥有最大魔力值的魔法师<code>max_index</code>，那么位于它之前的魔法师都将会被传送走，此具有最大魔力值的魔法师会留下来；接着寻找从<code>max_index + 1</code>到最后一个魔法师之间的拥有最大魔力值的魔法师，进行同样的操作，依次循环下去，直到剩下最后一个魔法师为止（最后一个魔法师肯定会留下来）；然而结果却超时了。于是换了种思维方式，既然是位于魔法师前面且比其魔力值小的魔法师会被传送走，那么最后一个魔法师肯定会留下来；直接定义一个存储最大魔力值的变量<code>max_num</code>，初始化为最后一个魔法师的魔力值，从后向前倒序遍历，如果当前魔法师的魔力值比<code>max_num</code>小，那么就把他传送走；否则，更新最大魔力值。</p><h3 id="TLE代码"><a href="#TLE代码" class="headerlink" title="TLE代码"></a>TLE代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxN = int(1e6 + 10);</span><br><span class="line">int n, a[maxN], l, r, max_index, cont;</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    l = 0; r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        vector&lt;int&gt; v(a + l, a + r);</span><br><span class="line">        auto max_value = max_element(v.begin(), v.end());</span><br><span class="line">        max_index = distance(begin(v), max_value);</span><br><span class="line">        cont += max_index;</span><br><span class="line">        l = l + max_index + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cont &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxN = int(1e6 + 10);</span><br><span class="line">int n, a[maxN], max_num, cont;</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    max_num = a[n];</span><br><span class="line">    <span class="keyword">for</span> (i = n - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; max_num) &#123;</span><br><span class="line">            cont++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max_num = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cont &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 程序设计竞赛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/default/hello-world/"/>
      <url>/default/hello-world/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建一篇新文章"><a href="#创建一篇新文章" class="headerlink" title="创建一篇新文章"></a>创建一篇新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>更多信息请查看： </p><ul><li><a href="https://hexo.io/zh-cn/docs/writing.html" target="_blank" rel="noopener">Writing</a> </li><li><a href="https://hexo.io/zh-cn/docs/tag-plugins" target="_blank" rel="noopener">标签插件（Tag Plugins）</a></li><li><a href="https://blog.csdn.net/zhuzhuyule/article/details/58347687" target="_blank" rel="noopener">Markdown语法(GFM)写博客</a></li><li><a href="http://www.cnblogs.com/youngwilliam/articles/youngwilliam.html" target="_blank" rel="noopener">HexoEditor, 一个写 Hexo 非常好用的 Markdown 编辑器</a></li><li><a href="https://github.com/zhuzhuyule/HexoEditor" target="_blank" rel="noopener">HexoEditor</a></li></ul><h3 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>更多信息请查看： <a href="https://hexo.io/zh-cn/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>更多信息请查看： <a href="https://hexo.io/zh-cn/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="发布到远程站点"><a href="#发布到远程站点" class="headerlink" title="发布到远程站点"></a>发布到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>更多信息请查看： <a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ gulp</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><h3 id="关于图片素材"><a href="#关于图片素材" class="headerlink" title="关于图片素材"></a>关于图片素材</h3><p>图片素材按官方教程说法，可统一放置在source/images目录中，并以<code>![](/images/image.jpg)</code> 方式引用。或者在<code>_config.yml</code>打开 post_asset_folder 功能，将当前文章所用的图片放置到source目录下的文章同名资源目录下，以<code>![](image.jpg)</code>方式引用</p><h3 id="使用-Hexo-Admin-插件"><a href="#使用-Hexo-Admin-插件" class="headerlink" title="使用 Hexo Admin 插件"></a>使用 Hexo Admin 插件</h3><p>Hexo Admin是一个本地在线式文章管理器，可以用直观可视化的方式新建、编辑博客文章、page页面，添加标签、分类等，并且支持剪贴板粘贴图片（自动在source_images_目录中创建文件）。<br><img src="/images/hexoadmin.png" alt=""></p><ul><li><p>在Hexo网站目录下，安装 Hexo Admin 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-admin</span><br></pre></td></tr></table></figure></li><li><p>启动本地服务器并打开管理界面，即可使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server -d</span><br><span class="line">$ open http://localhost:4000/admin/</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用HexoEditor-Markdown-编辑器"><a href="#使用HexoEditor-Markdown-编辑器" class="headerlink" title="使用HexoEditor Markdown 编辑器"></a>使用HexoEditor Markdown 编辑器</h3><blockquote><p>设置 npm 缓存路径</p><blockquote><p>Windows 下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">"C:/Program Files/nodejs/npm_global"</span></span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">"C:/Program Files/nodejs/npm_cache"</span></span><br></pre></td></tr></table></figure></p></blockquote></blockquote><blockquote><blockquote><p>Linux\Mac 下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">"~/nodejs/npm_global"</span></span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">"~/nodejs/npm_cache"</span></span><br></pre></td></tr></table></figure></p></blockquote></blockquote><blockquote><blockquote><p>注意：这里的路径是你安装 nodejs 的子目录下对应的路径</p></blockquote></blockquote><blockquote><p>设置下载来源（镜像），加速下载<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry <span class="string">"https://registry.npm.taobao.org/"</span></span><br><span class="line">npm config <span class="built_in">set</span> electron_mirror <span class="string">"https://npm.taobao.org/mirrors/electron/"</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>下载 GitHub 上最新的版本并安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zhuzhuyule/HexoEditor.git</span><br><span class="line"><span class="built_in">cd</span> HexoEditor</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="使用github-pages服务搭建博客的好处"><a href="#使用github-pages服务搭建博客的好处" class="headerlink" title="使用github pages服务搭建博客的好处"></a>使用github pages服务搭建博客的好处</h3><ol><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li><li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台。</li></ol>]]></content>
      
      <categories>
          
          <category> default </category>
          
      </categories>
      
      
        <tags>
            
            <tag> default </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><ul><li>我叫赵鹏</li><li>男</li><li>石家庄人</li><li>现居北京</li><li>学生</li></ul><h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><ul><li>Email：<a href="mailto:424107420@qq.com" target="_blank" rel="noopener">424107420@qq.com</a></li><li>GitHub：zhaopeng0103</li><li>WeChat：zp18713598785</li><li>QQ：424107420</li></ul>]]></content>
    </entry>
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    </entry>
    
    <entry>
      <title>标签云</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    </entry>
    
  
</search>
