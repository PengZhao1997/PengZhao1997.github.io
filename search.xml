<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[贪心算法-任务调度问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Problem E.任务调度问题时间限制 1000 ms内存限制 128 MB 题目描述一个单位时间任务是恰好需要一个单位时间完成的任务。给定一个单位时间任务的有限集 S 。关于S 的一个时间表用于描述S 中单位时间任务的执行次序。时间表中第 1 个任务从时间 0 开始执行直至时间 1 结束，第 2 个任务从时间 1 开始执行至时间 2 结束，…，第n个任务从时间 n-1 开始执行直至时间 n 结束。具有截止时间和误时惩罚的单位时间任务时间表问题可描述如下：(1) n 个单位时间任务的集合 S = {1,2,…,n}（n ≤ 500）；(2) 任务i的截止时间 d[i], 1 ≤ i ≤ n, 1 ≤ d[i] ≤ n，即要求任务 i 在时间 d[i] 之前结束；(3) 任务 i 的误时惩罚 1 ≤ w[i] ≤ 1000, 1 ≤ i ≤ n, 即任务 i 未在时间 d[i] 之前结束将招致 w[i] 的惩罚；若按时完成则无惩罚。任务时间表问题要求确定 S 的一个时间表（最优时间表）使得总误时惩罚达到最小。 输入数据第一行是正整数 n ，表示任务数。接下来的 2 行中，每行有 n 个正整数，分别表示各任务的截止时间和误时惩罚。 输出数据将计算出的最小总误时惩罚输出。 样例输入12374 2 4 3 1 4 670 60 50 40 30 20 10 样例输出150 题解这道题目类似于活动安排问题。首先将所有任务按照误时惩罚从大到小排序，然后依次从左到右遍历每个任务，将其安排在离截止时间点最近的（包括截止时间点处）未安排任务的时间点处完成，若无法找到这个时间点，则这个任务无法按时完成，将其误时惩罚加到总误时惩罚中。这样得到的总误时惩罚是最小的。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int n, d[510], w[510], visit[510];int i, j;long long result;int main() &#123; memset(visit, 0, sizeof(visit)); cin &gt;&gt; n; for (i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; d[i]; &#125; for (i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i]; &#125; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt; n; j++) &#123; if (w[j] &lt; w[j + 1]) &#123; swap(d[j], d[j + 1]); swap(w[j], w[j + 1]); &#125; &#125; &#125; for (i = 1; i &lt;= n; i++) &#123; bool flag = false; for (j = d[i]; j &gt; 0; j--) &#123; if (!visit[j]) &#123; visit[j] = 1; flag = true; break; &#125; &#125; if (!flag) &#123; result += w[i]; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法-合并果子]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90%2F</url>
    <content type="text"><![CDATA[Problem B.合并果子时间限制 1000 ms内存限制 128 MB 题目描述在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。 输入数据输入包括两行，第一行是一个整数n(1 &lt;＝ n &lt; 10^4)，表示果子的种类数。第二行包含 n 个整数，用空格分隔，第 i 个整数ai(1 &lt;＝ ai &lt; 2 * 10^4)是第 i 种果子的数目。 输出数据输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 2^31 。 样例输入1231 2 9 样例输出115 题解这道题类似于哈夫曼编码树。首先用一个优先队列存储每种果子的数目，定义比较函数为从大到小排序。然后从队列中取出数目最少的两种果子，合并到一起，并将合并后的结果重新放入优先队列中，同时体力耗费增加相应的值。依此类推，直到将所有种类的果子合并成一堆。这样所得到的体力耗费值是最小的。 AC代码123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;long long int n, a, temp, result;priority_queue&lt;long long int, vector&lt;long long int&gt;, greater&lt;long long int&gt;&gt; fruits;int i;int main() &#123; cin &gt;&gt; n; for (i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; fruits.push(a); &#125; while (fruits.size() &gt; 1) &#123; temp = 0; for (i = 0; i &lt; 2; i++) &#123; temp += fruits.top(); fruits.pop(); &#125; fruits.push(temp); result += temp; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大稳定极值区域MSER-Maximally Stable Extrernal Regions]]></title>
    <url>%2F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D%2F%E6%9C%80%E5%A4%A7%E7%A8%B3%E5%AE%9A%E6%9E%81%E5%80%BC%E5%8C%BA%E5%9F%9FMSER-Maximally-Stable-Extrernal-Regions%2F</url>
    <content type="text"><![CDATA[基本原理MSER基于分水岭的概念：对图像进行二值化，二值化阈值取[0, 255]，这样二值化图像就经历一个从全黑到全白的过程（就像水位不断上升的俯瞰图）。在这个过程中，有些连通区域面积随阈值上升的变化很小，这种区域就叫MSER。其中Qi表示第i个连通区域的面积，Δ表示微小的阈值变化（注水），当vi小于给定阈值时认为该区域为MSER。显然，这样检测得到的MSER内部灰度值是小于边界的，想象一副黑色背景白色区域的图片，显然这个区域是检测不到的。因此对原图进行一次MSER检测后需要将其反转，再做一次MSER检测，两次操作又称MSER+和MSER-。 Python源码实现1234567891011121314import cv2import matplotlib.pyplot as pltim = cv2.imread('./source.jpg')gray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)mser = cv2.MSER_create(_min_area=300)regions, boxes = mser.detectRegions(gray)for box in boxes: x, y, w, h = box cv2.rectangle(im, (x, y),(x + w, y + h), (255, 0, 0), 2)cv2.imwrite("./mser.jpg", im)]]></content>
      <categories>
        <category>目标检测与定位</category>
      </categories>
      <tags>
        <tag>MSER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法_最小差距]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E5%B7%AE%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[Problem A. 最小差距时间限制 1000 ms内存限制 128 MB 题目描述给定一些不同的一位数字，你可以从这些数字中选择若干个，并将它们按一定顺序排列，组成一个整数，把剩下的数字按一定顺序排列，组成另一个整数。组成的整数不能以0开头（除非这个整数只有1位）。例如，给定6个数字，0,1,2,4,6,7，你可以用它们组成一对数10和2467，当然，还可以组成其他的很多对数，比如210和764，204和176。这些对数中两个数差的绝对值最小的是204和176，为28。给定N个不同的0-9之间的数字，请你求出用这些数字组成的每对数中，差的绝对值最小的一对（或多对）数的绝对值是多少？ 输入数据第一行包括一个数 T （T ≤ 1000），为测试数据的组数。每组数据包括两行，第一行为一个数 N （2 ≤ N ≤ 10），表示数字的个数。下面一行为 N 个不同的一位数字。 输出数据T 行，每行一个数，表示第 i 个数据的答案。即最小的差的绝对值。 样例输入12345260 1 2 4 6 741 6 3 4 样例输出12285 题解首先将所有数字从小到大排序，接着这道题可以分三种情况考虑：（1）只有两个数的情况：直接两数相减取绝对值即可。（2）奇数个数的情况：首先保证第一个数字非0，如果为0，就将第一个数与第二个数交换位置，然后从左往右连续取n/2+1个数组成第一个整数，最后从右往左连续取n/2个数，即剩下的所有数组成另一个整数。这样所求得的一对整数的差的绝对值最小。（3）偶数个数的情况：从左往右依次枚举，首先保证第一个数非0，如果为0，就从下一个数开始枚举；取第k个数作为第一个整数的第一个数字，取第k+1个数作为第二个整数的第一个数字；然后，对于剩下的数字，从右往左连续取n/2-1个数加入第一个整数中，从左往右连续取n/2-1个数加入第二个整数中；最后，取差的绝对值最小的一对整数。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int t, n, d[20], num1, num2;int i, j, k, l, r;int main() &#123; scanf("%d", &amp;t); for (i = 0; i &lt; t; i++) &#123; scanf("%d", &amp;n); for (j = 1; j &lt;= n; j++) &#123; scanf("%d", &amp;d[j]); &#125; sort(d + 1, d + n + 1); if (n == 2) &#123; // 两个数的情况 printf("%d\n", abs(d[2] - d[1])); &#125; else if (n % 2 == 1) &#123; // 奇数个数的情况 if (d[1] == 0) &#123; swap(d[1], d[2]); &#125; num1 = 0, num2 = 0; // 前n/2+1个数从左往右组成第一个整数 for (j = 1; j &lt;= n / 2 + 1; j++) &#123; num1 = num1 * 10 + d[j]; &#125; // 后n/2个数从右往左组成第二个整数 for (j = n; j &gt;= n / 2 + 2; j--) &#123; num2 = num2 * 10 + d[j]; &#125; printf("%d\n", abs(num1 - num2)); &#125; else &#123; // 偶数个数的情况 int result = 0x7fffffff; // 枚举，取第k个数加入第一个整数中，取第k+1个数加入第二个整数中 for (j = 1; j &lt; n; j++) &#123; if (d[j] == 0) &#123; continue; &#125; num1 = d[j], num2 = d[j + 1]; // 从右往左遍历n/2-1个数加入第一个整数中 // 从左往右遍历n/2-1个数加入第二个整数中 l = 1, r = n; for (k = 0; k &lt; n / 2 - 1; k++) &#123; if (l == j) l++; if (l == j + 1) l++; if (r == j + 1) r--; if (r == j) r--; num1 = num1 * 10 + d[r]; num2 = num2 * 10 + d[l]; l++, r--; &#125; // 取差最小的值 result = min(result, abs(num1 - num2)); &#125; printf("%d\n", result); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法_旅行]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[Problem D. 旅行时间限制 1000 ms内存限制 128 MB 题目描述某趟列车的最大载客容量为V人，沿途共有n个停靠站，其中始发站为第1站，终点站为第n站。在第1站至第n-1站之间，共有m个团队申请购票搭乘，若规定：（1）对于某个团队的购票申请，要么全部满足，要么全部拒绝，即不允许只满足部分。（2）每个乘客的搭乘费用为其所乘站数。问：应如何选择这些购票申请，能使该趟列车获得最大的搭乘费用？其中，每个团队的购票申请格式是以空格分隔的三个整数：a b t，即表示有t个人需要从第a站点乘至第b站点（注：每个团队的所有人员都必须同时在a站上车，且必须同时在后面的b站下车）。 输入数据输入数据有若干行。第 1 行只有三个整数 n，m，v，分别表示站点数、申请数、列车的最大载客容量。这三个整数之间都以一个空格分隔。第 2 行至第 m+1 行，每行有三个整数，中间都以一个空格分隔。其中第 k+1 行的三个整数 a，b，t 表示第 k 个申请，含义为：有 t 个人需要从第 a 站乘至第 b 站。其中：1 ≤ n ≤ 10；1 ≤ m ≤ 18 输出数据输出数据只有一行，该行只有一个整数，为该列车能获得的最大搭乘费用。 样例输入12343 3 51 2 22 3 51 3 4 样例输出18 题解这道题与0-1背包问题类似。直接枚举所有可能的方案数，对于每一个团队，只有两个选择，搭乘与不搭乘，可以采用二进制0与1枚举的方式。由于团队申请数目m最多只有18个，所以最多有2^18种方案。对于每一种方案，统计每一站车上的总人数，如果某一站车上总人数超过了列车的最大载客容量v，那么此方案不可行；否则，比较搭乘费用，取最大的搭乘费用即可。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int n, m, v, a[20], b[20], t[20], num[25];long long cost = 0, temp;bool flag;int i, j;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; v; for (i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; t[i]; &#125; // 枚举二进制方案数 for (i = 0; i &lt; (1 &lt;&lt; m); i++) &#123; // 变量的初始化 temp = 0; flag = true; memset(num, 0, sizeof(num)); // 判断决定每一个团队是否可以搭乘 for (j = 0; j &lt; m; j++) &#123; if (i &amp; (1 &lt;&lt; j)) &#123; num[a[j]] += t[j]; num[b[j]] -= t[j]; temp += (b[j] - a[j]) * t[j]; &#125; &#125; // 统计每一站车上的总人数，如果大于容量，就不满足条件 for (j = 1; j &lt;= n; j++) &#123; num[j] += num[j - 1]; if (num[j] &gt; v) &#123; flag = false; &#125; &#125; // 满足条件则取最大搭乘费用 if (flag) &#123; cost = max(cost, temp); &#125; &#125; cout &lt;&lt; cost &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非极大值抑制NMS(Non-Maximum Suppression)]]></title>
    <url>%2F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D%2F%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6NMS-Non-Maximum-Suppression%2F</url>
    <content type="text"><![CDATA[介绍NMS顾名思义就是抑制不是极大值的元素，可以理解为局部最大搜索。这个局部代表的是一个邻域，邻域有两个参数可变，一是邻域的维数，二是邻域的大小。在目标检测中NMS主要用于提取分数最高的候选框。例如在用训练好的模型进行测试时，网络会预测出一系列的候选框，这时候可以用NMS来移除一些多余的候选框，即移除一些IOU值大于某个阈值的框。再比如在行人检测中，滑动窗口经提取特征，经分类器分类识别后，每个窗口都会得到一个分数。但是滑动窗口会导致很多窗口与其他窗口存在包含或者大部分交叉的情况。这时就需要用NMS来选取那些邻域里分数最高（是行人的概率最大）的窗口，并且抑制那些分数低的窗口。NMS在计算机视觉领域有着非常重要的应用，如视频目标跟踪、数据挖掘、3D重建、目标识别以及纹理分析等等。 NMS在目标检测中的应用去除重叠人脸检测框的例子如上图所示，目的就是要去除冗余的检测框，找到最佳的候选框。 目标检测pipline中的例子如上图所示，产生proposal后使用分类网络给出每个框的每类置信度，使用回归网络修正位置，最后使用NMS去除冗余的检测框。 NMS算法原理对于bounding boxes列表B及其相应的置信度S，使用下述计算方式：选择具有最大score的检测框M，将其从B集合中移除并加入到最后的检测结果R中。通常将B中剩余检测框与M的IOU大于阈值threshold的框从B中移除。重复这个过程，直到B为空。其中用到的排序，可以按照检测框右下角的坐标或者面积排序，也可以通过SVM等分类器得到的得分或概率进行排序，R-CNN中就是按照得分进行的排序。比如上图，定位一个车辆的位置，算法找出了许多检测框，这时需要判断哪些矩形框是没用的。非极大值抑制的方法是：先假设有6个矩形框，按照候选框的类别分类概率排序，假设属于车辆的概率排序结果为A &lt; B &lt; C &lt; D &lt; E &lt; F。 先从最大概率矩形框F开始，分别判断A~E与F的IOU值是否大于某个设定的阈值； 假设B、D与F的重叠度超过设定的阈值，那么就移除B和D；并标记第一个矩形框F，是保留下来的。 从剩下的矩形框A、C、E中，选择概率最大的E，然后判断E与A、C的重叠度，如果重叠度大于设定的阈值，那么就扔掉；并标记E是保留下来的第二个矩形框。 就这样一直重复，直到找到所有被保留下来的矩形框。 Python源码实现12345678910111213141516171819202122232425262728293031323334353637def py_cpu_nms(dets, thresh): """ Pure Python NMS baseline. """ # x1、y1、x2、y2、以及score赋值 x1 = dets[:, 0] y1 = dets[:, 1] x2 = dets[:, 2] y2 = dets[:, 3] scores = dets[:, 4] # 每一个候选框的面积 areas = (x2 - x1 + 1) * (y2 - y1 + 1) # 按照score置信度降序排序 order = scores.argsort()[::-1] keep = [] # 保留的结果框集合 while order.size &gt; 0: i = order[0] keep.append(i) # 保留该类剩余box中得分最高的一个 # 计算当前概率最大矩形框与其他矩形框的相交框的坐标 xx1 = np.maximum(x1[i], x1[order[1:]]) yy1 = np.maximum(y1[i], y1[order[1:]]) xx2 = np.minimum(x2[i], x2[order[1:]]) yy2 = np.minimum(y2[i], y2[order[1:]]) # 计算相交的面积，不重叠时面积为0 w = np.maximum(0.0, xx2 - xx1 + 1) h = np.maximum(0.0, yy2 - yy1 + 1) inter = w * h #计算IoU：重叠面积 /（面积1+面积2-重叠面积） over = inter / (areas[i] + areas[order[1:]] - inter) # 保留IoU小于阈值的矩形框索引 inds = np.where(over &lt;= thresh)[0] # 将order序列更新，由于前面得到的矩形框索引要比矩形框在原order序列中的索引小1，所以要把这个1加回来 order = order[inds + 1] return keep # 获取保留下来的索引]]></content>
      <categories>
        <category>目标检测与定位</category>
      </categories>
      <tags>
        <tag>NMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交并比IOU(Intersection over Union)]]></title>
    <url>%2F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D%2F%E4%BA%A4%E5%B9%B6%E6%AF%94IOU-Intersection-over-Union%2F</url>
    <content type="text"><![CDATA[基本原理IOU是在目标检测中使用的一个概念，是产生的预测框(Predicted bounding box)与标注框(Ground-truth bounding box)的重叠率；简单来说，即两个矩形框面积的交集和并集的比值；它是一个在特定数据集中检测相应物体准确度的测量标准。通常会在HOG + Linear SVM object detectors和Convolutional Neural Network detectors (R-CNN, Faster R-CNN, YOLO 等)中使用该方法检测其性能。IOU是一个简单的测量标准，在输出中得出一个预测范围(bounding box)的任务都可以用IOU来测量。其用于测量真实和预测之间的相关度，相关度越高，该值越高。上图展示了ground-truth和predicted的结果，绿色标线是人为标记的正确结果，红色标线是算法预测出来的结果，IOU要做的就是在这两个结果中测量算法的准确度。一般来说，这个比值 ＞ 0.5 就可以认为是一个不错的结果了。 Python源码实现123456789101112131415161718192021222324252627282930313233import numpy as npdef compute_iou(box1, box2, wh=False): """ compute the iou of two boxes. args: box1, box2: [xmin, ymin, xmax, ymax] (wh=False) or [xcenter, ycenter, w, h] (wh=True) wh: the format of coordinate. return: iou: iou of box1 and box2. """ if wh == False: xmin1, ymin1, xmax1, ymax1 = box1 xmin2, ymin2, xmax2, ymax2 = box2 else: xmin1, ymin1 = int(box1[0] - box1[2] / 2.0), int(box1[1] - box1[3] / 2.0) xmax1, ymax1 = int(box1[0] + box1[2] / 2.0), int(box1[1] + box1[3] / 2.0) xmin2, ymin2 = int(box2[0] - box2[2] / 2.0), int(box2[1] - box2[3] / 2.0) xmax2, ymax2 = int(box2[0] + box2[2] / 2.0), int(box2[1] + box2[3] / 2.0) ## 计算两个矩形框面积 area1 = (xmax1 - xmin1) * (ymax1 - ymin1) area2 = (xmax2 - xmin2) * (ymax2 - ymin2) ## 获取矩形框交集对应的左上角和右下角的坐标（intersection） inter_x1 = np.max([xmin1, xmin2]) inter_y1 = np.max([ymin1, ymin2]) inter_x2 = np.min([xmax1, xmax2]) inter_y2 = np.min([ymax1, ymax2]) inter_area = (np.max([0, inter_x2 - inter_x1])) * (np.max([0, inter_y2 - inter_y1])) # 计算交集面积 iou = inter_area / (area1 + area2 - inter_area + 1e-6) ＃ 计算交并比 return iou]]></content>
      <categories>
        <category>目标检测与定位</category>
      </categories>
      <tags>
        <tag>IOU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基本常用命令]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2FGit%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git init 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。 git add XX 把xx文件添加到暂存区去。 git commit -m ‘XX’ 提交文件， –m 后面的是注释。 git status 查看本地仓库状态。 git diff XX 查看XX文件修改了那些内容。 git log 查看历史记录。 git reset -hard HEAD^ 或者 git reset –hard HEAD~ 回退到上一个版本(如果想回退到100个版本，使用git reset –hard HEAD~100 )。 cat XX 查看XX文件内容。 git reflog 查看历史记录的版本号id。 git checkout – XX 把XX文件在工作区的修改全部撤销。 git rm XX 删除XX文件。 git remote add origin https://github.com/zhaopeng0103/test.git 关联一个远程库。 git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库。 git clone https://github.com/zhaopeng0103/test.git 从远程库中克隆。 git checkout –b dev 创建dev分支，并切换到dev分支上。 git branch 查看当前所有的分支。 git checkout master 切换回master分支。 git merge dev 在当前的分支上合并dev分支。 git branch –d dev 删除dev分支。 git branch name 创建分支。 git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作。 git stash list 查看所有被隐藏的文件列表。 git stash apply 恢复被隐藏的文件，但是内容不删除。 git stash drop 删除文件。 git stash pop 恢复文件的同时 也删除文件。 git remote 查看远程库的信息。 git remote –v 查看远程库的详细信息。 git push origin master Git会把master分支推送到远程库对应的远程分支上。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好听的歌曲]]></title>
    <url>%2Fmusic%2F%E5%A5%BD%E5%90%AC%E7%9A%84%E6%AD%8C%E6%9B%B2%2F</url>
    <content type="text"><![CDATA[var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","music":[{"title":"小白兔遇上卡布奇诺","author":"兔子牙","url":"/music/小白兔遇上卡布奇诺.mp3","pic":"/images/小白兔1.jpg","lrc":"/documents/小白兔.txt"}]}; options.element = document.getElementById("aplayer-DbmCZTgH"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","video":{"url":"/videos/小白兔.mp4","pic":"/images/小白兔.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>music</category>
      </categories>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计竞赛:五子棋]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E4%BA%94%E5%AD%90%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[Problem E. 五子棋时间限制 1000 ms内存限制 64 MB 题目描述在一个nxn的棋盘上，有一些黑色的棋子和白色的棋子，如果能找出任意五个同色的棋子连成直线（横着、竖着、斜着都可以），那么该颜色方加1分。求黑色方得分和白色方得分。 输入数据第一行为一个正整数n，代表棋盘的大小。 接下来为一个nxn的矩阵，’#’代表没有棋子，’B’代表黑色棋子，’W’代表白色棋子 n&lt;=20 输出数据两个正整数，分别代表黑色方得分和白色方得分 样例输入12345676WBBBBBWBB###W###B#W###B#W###B#W###B# 样例输出11 2 题解直接遍历每一个棋子，如果在下图中的任一个方向连成5个，则对应方加1分。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int maxN = 40;int n;int a[maxN][maxN], b_score, w_score;string s;int i, j;int main() &#123; memset(a, 0, sizeof(a)); cin &gt;&gt; n; for (i = 3; i &lt; n + 3; i++) &#123; cin &gt;&gt; s; for (j = 0; j &lt; s.length(); j++) &#123; if (s[j] == 'B') &#123; a[i][j + 3] = 1; &#125; if (s[j] == 'W') &#123; a[i][j + 3] = 2; &#125; &#125; &#125; for (i = 3; i &lt; n + 3; i++) &#123; for (j = 3; j &lt; n + 3; j++) &#123; if (a[i][j] == 1) &#123; if (a[i][j - 1] == a[i][j] &amp;&amp; a[i][j - 2] == a[i][j] &amp;&amp; a[i][j + 1] == a[i][j] &amp;&amp; a[i][j + 2] == a[i][j]) &#123; b_score++; &#125; if (a[i - 1][j] == a[i][j] &amp;&amp; a[i - 2][j] == a[i][j] &amp;&amp; a[i + 1][j] == a[i][j] &amp;&amp; a[i + 2][j] == a[i][j]) &#123; b_score++; &#125; if (a[i + 1][j + 1] == a[i][j] &amp;&amp; a[i + 2][j + 2] == a[i][j] &amp;&amp; a[i - 1][j - 1] == a[i][j] &amp;&amp; a[i - 2][j - 2] == a[i][j]) &#123; b_score++; &#125; if (a[i + 1][j - 1] == a[i][j] &amp;&amp; a[i + 2][j - 2] == a[i][j] &amp;&amp; a[i - 1][j + 1] == a[i][j] &amp;&amp; a[i - 2][j + 2] == a[i][j]) &#123; b_score++; &#125; &#125; if (a[i][j] == 2) &#123; if (a[i][j - 1] == a[i][j] &amp;&amp; a[i][j - 2] == a[i][j] &amp;&amp; a[i][j + 1] == a[i][j] &amp;&amp; a[i][j + 2] == a[i][j]) &#123; w_score++; &#125; if (a[i - 1][j] == a[i][j] &amp;&amp; a[i - 2][j] == a[i][j] &amp;&amp; a[i + 1][j] == a[i][j] &amp;&amp; a[i + 2][j] == a[i][j]) &#123; w_score++; &#125; if (a[i + 1][j + 1] == a[i][j] &amp;&amp; a[i + 2][j + 2] == a[i][j] &amp;&amp; a[i - 1][j - 1] == a[i][j] &amp;&amp; a[i - 2][j - 2] == a[i][j]) &#123; w_score++; &#125; if (a[i + 1][j - 1] == a[i][j] &amp;&amp; a[i + 2][j - 2] == a[i][j] &amp;&amp; a[i - 1][j + 1] == a[i][j] &amp;&amp; a[i - 2][j + 2] == a[i][j]) &#123; w_score++; &#125; &#125; &#125; &#125; cout &lt;&lt; b_score &lt;&lt; " " &lt;&lt; w_score &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>程序设计竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计竞赛:讨厌的数字]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E8%AE%A8%E5%8E%8C%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Problem D. 讨厌的数字时间限制 1000 ms内存限制 64 MB 题目描述奶牛的生日快到了，你准备送给他一个数x作为生日礼物，x是十进制下的一个n位数，但是奶牛向你提出了一些要求。 1 奶牛准备了一个数字d，他希望x是d的倍数 2 奶牛不喜欢0和3，他不希望x中有0或3 请问有多少个不同的n位数可以作为奶牛的生日礼物呢？ 答案mod1000000007输出。 输入数据两个数字n和d，代表数字位数和奶牛给出的数字d0 &lt;= n &lt;= 10000 &lt;= d &lt;= 1000 输出数据一个1000000007之内的整数代表答案 样例输入12 3 样例输出122 题解dp[i][j]表示i位数中模d等于j的方案数。首先计算只有一位数时，满足条件的方案数作为初始值。然后依次遍历i位数下对d求余为j的方案个数；每增加一位数，就在其最后加k，因为要求数字中不能出现0和3，那么遍历时直接去除这两个数字就可以了。最后n位数下是d的倍数的方案个数就是dp[n][0]。 AC代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int maxN = 1010;int n, d, dp[maxN][maxN];int i, j, k;int main() &#123; cin &gt;&gt; n &gt;&gt; d; // 计算一位数的方案数 for (k = 1; k &lt;= 9; k++) &#123; if (k == 3) &#123; continue; &#125; dp[1][k % d]++; &#125; // dp[i][j]表示i位数中模d等于j的方案数 for (i = 2; i &lt;= n; i++) &#123; for (j = 0; j &lt; d; j++) &#123; for (k = 1; k &lt;= 9; k++) &#123; if (k == 3) &#123; continue; &#125; dp[i][(j * 10 + k) % d] += dp[i - 1][j]; dp[i][(j * 10 + k) % d] %= 1000000007; &#125; &#125; &#125; cout &lt;&lt; dp[n][0] &lt;&lt; endl;// 输出n位数中能被d整除的满足条件的方案数 return 0;&#125;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>程序设计竞赛</tag>
        <tag>动态规划dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计竞赛:约瑟夫环plus]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AFplus%2F</url>
    <content type="text"><![CDATA[Problem C. 约瑟夫环plus时间限制 2000 ms内存限制 64 MB 题目描述考虑经典的约瑟夫环模型：n个人按顺序围成一圈，从第一个人开始报数，从1开始报，报到k这个数的人会被移出去，然后下一个人从1开始重新报数，第n个人报完数之后第1个人接着报数，问整个过程中第1个人报了几次数。 输入数据两个正整数n，k1 &lt;= n &lt;= 10000000000000000001 &lt;= k &lt;= 200 输出数据第1个人被移除之前一共报了几次数 样例输入14 4 样例输出13 样例说明注意n需要用long long存 题解cur_number存储第一个人每次轮到他时所报的号，最开始时，第一个人报号的次数res为1，cur_number也为1；从上一次这个人报号到下一次轮到他报号为止为一个周期，在这个周期内有(n + cur_number) / k个人被移出去，这个人报的号更新为(n + cur_number) % k；所以当(n + cur_number) % k = 0时，第一个人会被移出去，也就是下一次轮到他时cur_number = 0。 AC代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;long long n, k, cur_number, res, temp;int main() &#123; cin &gt;&gt; n &gt;&gt; k; res = 1; cur_number = 1; while (cur_number != 0) &#123; temp = n + cur_number; n -= temp / k; cur_number = temp % k; res++; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>程序设计竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计竞赛:魔法师排队]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E9%AD%94%E6%B3%95%E5%B8%88%E6%8E%92%E9%98%9F%2F</url>
    <content type="text"><![CDATA[Problem B. 魔法师排队时间限制 2000 ms内存限制 64 MB 题目描述有n个魔法师在排队买魔法面包，每个魔法师都有自己的魔力值，用一个正整数表示。 魔法师都不喜欢排队，如果任意时刻某个魔法师发现前面的魔法师的魔力值比自己小，那么这个魔法师就会用法术把前面的人传送到异空间。 请输出有多少个魔法师会被传送到异空间。 输入数据第一行为一个正整数n，代表魔法师的人数。 接下来一行位n个正整数，第i个正整数ai代表队伍中第i个魔法师的魔力值。（第1个魔法师在队头，第n个魔法师在队尾）1 &lt;= n &lt;= 10000001 &lt;= ai &lt;= 100000000 输出数据被传送到异空间的魔法师个数 样例输入1254 5 1 3 2 样例输出12 题解一开始的想法是：找从第一个魔法师到最后一个魔法师中的拥有最大魔力值的魔法师max_index，那么位于它之前的魔法师都将会被传送走，此具有最大魔力值的魔法师会留下来；接着寻找从max_index + 1到最后一个魔法师之间的拥有最大魔力值的魔法师，进行同样的操作，依次循环下去，直到剩下最后一个魔法师为止（最后一个魔法师肯定会留下来）；然而结果却超时了。于是换了种思维方式，既然是位于魔法师前面且比其魔力值小的魔法师会被传送走，那么最后一个魔法师肯定会留下来；直接定义一个存储最大魔力值的变量max_num，初始化为最后一个魔法师的魔力值，从后向前倒序遍历，如果当前魔法师的魔力值比max_num小，那么就把他传送走；否则，更新最大魔力值。 TLE代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int maxN = int(1e6 + 10);int n, a[maxN], l, r, max_index, cont;int i;int main() &#123; cin &gt;&gt; n; for (i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;a[i]); &#125; l = 0; r = n; while(l &lt; r) &#123; vector&lt;int&gt; v(a + l, a + r); auto max_value = max_element(v.begin(), v.end()); max_index = distance(begin(v), max_value); cont += max_index; l = l + max_index + 1; &#125; cout &lt;&lt; cont &lt;&lt; endl; return 0;&#125; AC代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int maxN = int(1e6 + 10);int n, a[maxN], max_num, cont;int i;int main() &#123; cin &gt;&gt; n; for (i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); &#125; max_num = a[n]; for (i = n - 1; i &gt; 0; i--) &#123; if (a[i] &lt; max_num) &#123; cont++; &#125; else &#123; max_num = a[i]; &#125; &#125; cout &lt;&lt; cont &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>程序设计竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fdefault%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 快速入门创建一篇新文章1$ hexo new "My New Post" 更多信息请查看： Writing 标签插件（Tag Plugins） Markdown语法(GFM)写博客 HexoEditor, 一个写 Hexo 非常好用的 Markdown 编辑器 HexoEditor 运行服务1$ hexo server 更多信息请查看： Server 生成静态文件1$ hexo generate 更多信息请查看： Generating 发布到远程站点1$ hexo deploy 更多信息请查看： Deployment 常用命令1234$ hexo clean$ hexo g$ gulp$ hexo d or 1$ hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d 关于图片素材图片素材按官方教程说法，可统一放置在source/images目录中，并以![](/images/image.jpg) 方式引用。或者在_config.yml打开 post_asset_folder 功能，将当前文章所用的图片放置到source目录下的文章同名资源目录下，以![](image.jpg)方式引用 使用 Hexo Admin 插件Hexo Admin是一个本地在线式文章管理器，可以用直观可视化的方式新建、编辑博客文章、page页面，添加标签、分类等，并且支持剪贴板粘贴图片（自动在source_images_目录中创建文件）。 在Hexo网站目录下，安装 Hexo Admin 插件 1$ npm install --save hexo-admin 启动本地服务器并打开管理界面，即可使用 12$ hexo server -d$ open http://localhost:4000/admin/ 使用HexoEditor Markdown 编辑器 设置 npm 缓存路径 Windows 下:12npm config set prefix "C:/Program Files/nodejs/npm_global"npm config set cache "C:/Program Files/nodejs/npm_cache" Linux\Mac 下:12npm config set prefix "~/nodejs/npm_global"npm config set cache "~/nodejs/npm_cache" 注意：这里的路径是你安装 nodejs 的子目录下对应的路径 设置下载来源（镜像），加速下载12npm config set registry "https://registry.npm.taobao.org/"npm config set electron_mirror "https://npm.taobao.org/mirrors/electron/" 下载 GitHub 上最新的版本并安装123git clone https://github.com/zhuzhuyule/HexoEditor.gitcd HexoEditornpm install 启动1npm start 使用github pages服务搭建博客的好处 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台。]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[关于我 我叫赵鹏 男 石家庄人 现居北京 学生 联系我 Email：424107420@qq.com GitHub：zhaopeng0103 WeChat：zp18713598785 QQ：424107420]]></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[标签云]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
